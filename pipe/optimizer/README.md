# Optimizer Pipe

## Overview

The Optimizer Pipe (`optimizer.py`) is an executable script that orchestrates a sequence of agents (steps) to perform automated C++ performance analysis, code modification proposals, patching, and re-profiling of variants. It provides a user-friendly command-line interface to run the Profiler, Analyzer, Replicator, and Patcher agents in a connected pipeline, and then re-profiles the generated code variants.

This pipe is intended to simplify the process of:
1.  Profiling C++ code to gather performance data for one or more source files.
2.  Analyzing the performance data to identify bottlenecks.
3.  Generating potential code variants to address these bottlenecks.
4.  Saving these code variants as new source files.
5.  Profiling each of the generated and saved code variants.
6.  Evaluating each profiled variant against a baseline (initially the original code, then the best variant from the previous iteration).
7.  Iteratively refining the code by using the best variant's profile as input for further analysis if multiple iterations are run.

## Functionality

-   **File Discovery:** Recursively finds C++ source files (`.cpp`, `.cc`, `.cxx`) in a specified input directory.
-   **Orchestration:** For each found C++ file, sequentially runs the `Profiler` (initial), `Analyzer`, `Replicator`, and `Patcher` agents. Then, for each successfully patched variant, it runs the `Profiler` (for variant) and `Evaluator` agents.
-   **Data Flow:** Manages the flow of data between these agents, using the output of one step as the input for the next.
-   **Variant Profiling & Evaluation:** After the Patcher saves the code variants, the pipe individually profiles each successfully patched variant and then runs the Evaluator to compare its performance against the current baseline profile.
-   **Iterative Improvement:** If multiple iterations are specified, the `Analyzer` in subsequent iterations will use the profile data from the best-performing variant of the previous iteration as its input, allowing for progressive optimization attempts.
-   **Input:** Takes an input directory containing C++ source files and a general output directory.
-   **Output:** Saves the YAML output from each agent step (`Profiler`, `Analyzer`, `Replicator`, `Patcher`, `Evaluator`) and the Profiler outputs for each variant into a structured hierarchy within the specified output directory.
-   **Iteration:** Supports multiple optimization iterations for each C++ file. The best variant from one iteration becomes the baseline for the next.

## How to Run

The Optimizer Pipe is run from the command line, typically from the root of the `profiling-agent` project directory.

```bash
python -m pipe.optimizer.optimizer --input-dir <path_to_cpp_source_directory> --output-dir <path_to_output_directory>
```

**Command-Line Arguments:**

-   `--input-dir` (string, **required**):
    Path to the directory containing the C++ source files (`.cpp`, `.cc`, `.cxx`) to be processed. The script will search recursively.
    *Example:* `examples/cpp_sources/`

-   `--output-dir` (string, **required**):
    Path to a directory where all intermediate and final YAML outputs from each agent in the pipeline, as well as patched source files and their profiling results, will be saved. The directory will be created if it doesn't exist. Subdirectories will be created for each processed source file and each iteration.
    *Example:* `./optimizer_run_outputs`

-   `--iterations` (integer, optional, default: `1`):
    The number of times to run the Profiler -> Analyzer -> Replicator -> Patcher -> Profile Variants -> Evaluate Variants sequence for each discovered C++ file.
    **Note:** Currently, each iteration starts by profiling the *original* source file.

**Example Usage:**

```bash
# Ensure you are in the root directory of the profiling-agent project
poetry run python -m pipe.optimizer.optimizer \
    --input-dir data/sources/ \
    --output-dir ./optimizer_run_1 \
    --iterations 1
```

## Pipeline Steps & Outputs (per C++ file, per iteration)

For each C++ source file found in `--input-dir`, and for each iteration:

1.  **Initial Profiler Agent:**
    -   Input: The directory containing the current C++ source file. An input YAML (`profiler_input_initial_{original_filename}.yaml`) is generated by the pipe.
    -   Output: `profiler_output.yaml` (saved in `<output-dir>/<sanitized_source_path>/iter_<N>/`). This contains original `source_code`, `perf_command`, and `perf_report_output`. This becomes the initial `baseline_profiler_output` for the first iteration.

2.  **Analyzer Agent:**
    -   Input: Takes the `baseline_profiler_output` (from step 1 in the first iteration, or from the best variant of the previous iteration in subsequent iterations).
    -   Output: `analyzer_output.yaml` (saved in the same iteration directory). This includes `performance_analysis` and structured bottleneck details.

3.  **Replicator Agent:**
    -   Input: Takes `analyzer_output.yaml` from the previous step.
    -   Output: `replicator_output.yaml` (saved in the same iteration directory). This contains `replication_strategy` and `modified_code_variants`.

4.  **Patcher Agent:**
    -   Input: Takes `replicator_output.yaml`. The pipe injects `original_file_name`.
    -   Output: 
        -   `patcher_output.yaml` (saved in the same iteration directory). Details success/failure of writing each variant.
        -   Patched source files for each variant (e.g., in `<output-dir>/<sanitized_source_path>/iter_<N>/profiler_run_variant_<sanitized_variant_id>/src/<original_filename>`).

5.  **Variant Processing Loop (for each successfully patched variant):**
    a.  **Profiler Agent (for variant):**
        -   Input: A temporary directory containing the single patched C++ variant. An input YAML (`profiler_input_variant_<sanitized_variant_id>.yaml`) is generated by the pipe.
        -   Output: `profiler_output_variant_<sanitized_variant_id>.yaml` (saved in `<output-dir>/<sanitized_source_path>/iter_<N>/profiler_run_variant_<sanitized_variant_id>/`). Contains profiling results for the specific code variant.
    b.  **Evaluator Agent (for variant):**
        -   Input: An `evaluator_input_<sanitized_variant_id>.yaml` generated by the pipe, containing paths to the current `baseline_profiler_output` and the `profiler_output_variant_<sanitized_variant_id>.yaml` for the current variant.
        -   Output: `evaluator_output_<sanitized_variant_id>.yaml` (saved in the same directory as the variant's profiler output). Contains the LLM's evaluation of the variant's performance against the baseline.

6.  **Best Variant Selection:**
    - After all variants in an iteration are profiled and evaluated, the pipe selects the best performing variant based on the Evaluator outputs.
    - If an improved variant is found, its `profiler_output_variant_...yaml` becomes the new `baseline_profiler_output` for the *next* iteration's Analyzer (Step 2).
    - If no variant is better, the existing `baseline_profiler_output` is carried over.

## Dependencies

-   Python 3.x
-   All dependencies for the `Profiler`, `Analyzer`, `Replicator`, `Patcher`, and `Evaluator` agents (including `core.utils`, and the respective agent modules).
-   External tools required by the agents (e.g., C++ compiler, Linux `perf`). 